# Память

D является системным языком программирования и позволяет вручную управлять памятью. Однако такое управление памятью довольно опасно и может приводить к ошибкам. Поэтому по умолчанию в D освобождением неиспользуемой памяти занимается *сборщик мусора*.

D предоставляет тип указателя `T*`, как в языке C:

    int a;
    int* b = &a; // b содержит адрес переменной a
    auto c = &a // c является int* и содержит
                // адрес переменной a

Новый блок памяти на куче выделяется с помощью выражения `new`, которое
возвращает указатель на управляемую сборщиком мусора память:

    int* a = new int;

Как только на память, на которую сейчас ссылается `a`, не будет больше ссылаться ни
одна переменная в программе, сборщик мусора освободит её.

В D есть три различных уровня защиты для функций: `@system`, `@trusted` и `@safe`.
Если не указано иное, по умолчанию используется `@system`. 
`@safe` это подмножество языка D, которое может быть использовано для предотвращения ошибок, связанных с доступом к памяти. Код, отмеченный как `@safe`, может вызывать только другие `@safe` или `@trusted` функции. Явные арифметические операции с указателями запрещены в коде, отмеченном как `@safe`:

    void main() @safe {
        int a = 5;
        int* p = &a;
        int* c = p + 5; // ошибка
    }

Функции `@trusted` - это вручную проверенные функции, позволяющие
связать мир SafeD и небезопасную низкоуровневую функциональность.

### Подробнее

* [SafeD](https://dlang.org/safed.html)

## {SourceCode}

```d
import std.stdio;

void safeFun() @safe
{
    writeln("Hello World");
    // выделение памяти с помощью сборщика мусора
    // также является безопасным
    int* p = new int;
}

void unsafeFun()
{
    int* p = new int;
    int* fiddling = p + 5;
}

void main()
{
    safeFun();
    unsafeFun();
}
```
