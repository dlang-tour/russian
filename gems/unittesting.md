# Юнит-тестирование

Тесты - это отличный способ создания стабильных, свободных от
багов приложений. Они служат интерактивной документацией и
позволяют модифицировать код без риска повреждения функционала.
D предоставляет удобный встроенный синтаксис для блоков
`unittest`, которые встроены непосредственно в язык.
Блоки `unittest` можно использовать в любом месте модуля для
проверки функционала кода.

    // Блок для моей функции
    unittest
    {
        assert(myAbs(-1) == 1);
        assert(myAbs(1)  == 1);
    }

Это позволяет при необходимости вести [разработку через тестирование](https://ry.wikipedia.org/wiki/Разработка_через_тестирование).

### Исполнение блоков `unittest`

Блоки `unittest` могут содержать произвольный код, который
будет скомпилирован и будет исполняться при каждом запуске
программы, если при компиляции указан флаг компилятора
`-unittest`. DUB также поддерживает компиляцию и исполнение
юнит-тестов посредством команды `dub test`.

### Проверка примеров при помощи `assert`

В типичном случае, `unittest`'ы содержат выражения `assert`,
тестирующие работоспособность той или иной функции.
Блоки `unittest` обычно располагают рядом с определением
функции - как на верхнем уровне исходного кода, так и
в теле определений классов и структур.

### Увеличение покрытия

Юнит-тесты - мощное оружие, позволяющее создавать пуленепробиваемые приложения.
Общепринятой метрикой проверки, насколько программа проверяется
тестами, является _покрытие кода_. Это отношение количества исполненных
строк кода к количеству фактических строк кода.
Компилятор DMD позволяет легко генерировать отчёты о покрытии
посредством ключа компилятора `-cov`, при использовании которого будут сгенерированы
файлы `.lst`, содержащие детальную статистику по каждому модулю.

Поскольку компилятор способен автоматически вычислять атрибуты для шаблонного
кода, указание атрибутов для блоков тестов является общепринятой практикой.
Это позволяет убедиться, что тестируемый код действительно содержит
указанные атрибуты.

    unittest @safe @nogc nothrow pure
    {
        assert(myAbs() == 1);
    }

### Подробнее

- [Unit Testing in _Programming in D_](http://ddili.org/ders/d.en/unit_testing.html)
- [Unittesting in D](https://dlang.org/spec/unittest.html)

## {SourceCode}

```d
import std.stdio : writeln;

struct Vector3 {
    double x;
    double y;
    double z;

    double dot(Vector3 rhs) const {
        return x*rhs.x + y*rhs.y + z*rhs.z;
    }

    // Так можно!
    unittest {
        assert(Vector3(1,0,0).dot(
          Vector3(0,1,0) == 0);
    }

    string toString() const {
        import std.string : format;
        return format("x:%.1f y:%.1f z:%.1f",
          x, y, z);
    }

    // .. и так тоже!
    unittest {
        assert(Vector3(1,0,0).toString() ==
          "x:1.0 y:0.0 z:0.0");
    }
}

void main()
{
    Vector3 vec = Vector3(0,1,0);
    writeln(`Этот вектор протестирован: `,
      vec);
}

/*
А можно и где угодно.
В обычном режиме ничего не будет скомпилировано.
Выполните dub test или скомпилируйте
командой dmd -unittest, чтобы протестировать
ваши модули.
*/
unittest {
    Vector3 vec;
    // .init - специальное встроенное свойство,
    // возвращающее начальное значение для типа.
    assert(vec.x == double.init);
}
```
