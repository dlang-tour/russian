# Исполнение функций во время компиляции (CTFE)

CTFE - это механизм, позволяющий компилятору исполнять
функции **во время компиляции**. Для использования этой
возможности не требуется ограниченное подмножество языка D:
любую функцию, зависящую только от значений, известных во
время компиляции, компилятор может решить исполнить во
время компиляции.

    // результат будет вычислен во время компиляции.
    // Проверьте машинный код, вызова функции там
    // не будет!
    static val = sqrt(50);

Ключевые слова вроде `static`, `immutable`, `enum`
указывают компилятору использовать CTFE там, где
это возможно.
Отличительной чертой данной техники является то,
что функции не нужно переписывать каким-либо особым образом
для её использования, один и тот же код используется
и во время компиляции, и во время исполнения:

    int n = doSomeRuntimeStuff();
    // та же функция, что и выше,
    // но в этот раз она будет вызвана классически,
    // во время исполнения.
    auto val = sqrt(n);

Ярким примером использования данной техники в D является
библиотека [std.regex](https://dlang.org/phobos/std_regex.html).
Она предоставляет тип `ctRegex`, использующий *строковые mixin'ы*
и CTFE для генерации во время компиляции высоко оптимизированного автомата
обработки регулярных выражений. Та же кодовая база используется
и версией времени исполнения `regex`, позволяющей работать
с регулярными выражениями, доступными только во время исполнения.

    auto ctr = ctRegex!(`^.*/([^/]+)/?$`);
    auto tr = regex(`^.*/([^/]+)/?$`);
    // ctr и tr взаимозаменяемы,
    // но ctr работает быстрее!

Не все возможности языка доступны во время CTFE,
но поддерживаемый набор увеличивается с каждой версией
компилятора.

### Подробнее

- [Introduction to regular expressions in D](https://dlang.org/regular-expression.html)
- [std.regex](https://dlang.org/phobos/std_regex.html)
- [Conditional compilation](https://dlang.org/spec/version.html)

## {SourceCode}

```d
import std.stdio : writeln;

/**
Вычисление квадратного корня
по методу Ньютона.

Params:
    x = число, из которого необходимо
        извлечь корень
    
Returns: квадратный корень x
*/
auto sqrt(T)(T x) {
    // epsilon - когда остановить аппроксимацию
    // (считаем, что разница незначительна,
    // и последующие итерации не требуются).
    enum GoodEnough = 0.01;
    import std.math : abs;
    // выбор подходящего начального значения
    T z = x*x, old = 0;
    int iter;
    while (abs(z - old) > GoodEnough) {
        old = z;
        z -= ((z*z)-x) / (2*z);
    }

    return z;
}

void main() {
    double n = 4.0;
    writeln("Кв. корень 4 время исполнения = ",
        sqrt(n));
    static cn = sqrt(4.0);
    writeln("Кв. корень 4 время компиляции = ",
        cn);
}
```
