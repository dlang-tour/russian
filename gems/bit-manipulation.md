# Манипулирование битами

Отличным примером способности D генерировать код во время компиляции при помощи
mixin'ов является манипулирование битами.

### Простое манипулирование битами

D предоставляет следующие операторы для манипулирования битами:

- `&` побитовое "и"
- `|` побитовое "или"
- `~` побитовое отрицание
- `<<`  побитовый знаковый    сдвиг влево
- `>>`  побитовый знаковый    сдвиг вправо (сохраняет знак в старшем бите)
- `>>>` побитовый беззнаковый сдвиг вправо

### На практике

Часто встречающийся пример работы с битами - чтение значения одного бита.
D предоставляет `core.bitop.bt` для часто встречающихся задач,
однако для начала, чтобы привыкнуть к работе с битами, давайте рассмотрим
полную реализацию методики проверки значения бита:

```d
enum posA = 1;
enum maskA = (1 << posA);
bool getFieldA()
{
    return _data & maskA;
}
```

Обобщением данной задачи является проверка блоков длиной более 1.
Для этого потребуется специальная маска требуемой длины,
и соответствующий сдвиг блока перед наложением маски:

```d
enum posA = 1;
enum lenA = 3;
enum maskA = (1 << lenA) - 1; // ...0111
uint getFieldA()
{
    return (_data >> posA) & maskA;
}
```

Установку битов в таком блоке так же можно описать как отрицание маски,
что позволит записывать значения только внутри заданного блока:

```d
void setFieldA(bool b);
{
    return (_data & ~maskAWrite) | ((b << aPos) & maskAWrite);
}
```

## `std.bitmanip` на помощь

Конечно, всегда весело работать с битами вручную, и D предлагает
для этого полный набор инструментов. Однако, в большинстве случаев
такой код придётся постоянно копировать, а это чревато ошибками
и с трудом поддаётся поддержке.
И здесь на помощь приходит модуль `std.bitmanip`, позволяющий писать
поддерживаемый, легко читаемый код, управляющий битами, посредством
мощного механизма mixin'ов, не теряя при этом в производительности.

Взгляните на раздел с упражнениями. В нём определён `BitVector`,
который использует лишь X битов, но при этом едва отличается от
обыкновенной структуры.

Модули `std.bitmanip` и `core.bitop` предоставляют значительный объём
вспомогательного кода для приложений, требующих малое потребление памяти.

### Отступ и выравнивание

Поскольку компилятор будет добавлять отступы для переменных размером
меньше, чем определено схемой размещения в текущей OS (`size_t.sizeof`),
например для типов `bool`, `byte`, `char`, рекомендуется начинать с полей
с б*о*льшим выравниванием.

## В деталях

- [std.bitmanip](http://dlang.org/phobos/std_bitmanip.html) - Средства управления битами
- [_Bit Packing like a Madman_](http://dconf.org/2016/talks/sechet.html)

## {SourceCode}

```d
struct BitVector
{
    import std.bitmanip : bitfields;
    // создаёт приваное поле со следующими
    // посредниками:
    mixin(bitfields!(
        uint, "x",    2,
        int,  "y",    3,
        uint, "z",    2,
        bool, "flag", 1));
}

void main()
{
    import std.stdio : writefln, writeln;

    BitVector vec;
    vec.x = 2;
    vec.z = vec.x - 1;
    writefln("x: %d, y: %d, z: %d",
              vec.x, vec.y, vec.z);

    // используется только 8 бит - 1 байт
    writeln(BitVector.sizeof);

    struct Vector { int x, y, z; }
    // 4 байта (int) на каждую переменную
    writeln(Vector.sizeof);

	struct BadVector
	{
		bool a;
		int x, y, z;
		bool b;
	}
	// из-за отступов, для каждого поля
	// используется 4 байта
	writeln(BadVector.sizeof);
}
```
