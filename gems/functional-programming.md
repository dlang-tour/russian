# Функциональное программирование

D особо выделяет *функциональное программирование*,
и предоставляет встроенную поддержку для разработки
в функциональном стиле.

В D функцию можно объявить как `pure`, что означает,
что при одних и тех же параметрах, всегда возвращается
**один и тот же** результат. `pure`-функции не могут
обращаться к или изменять глобальное состояние, и поэтому
могут вызывать только другие функции, помеченные как `pure`.

    int add(int lhs, int rhs) pure {
        // ОШИБКА: impureFunction();
        return lhs + rhs;
    }

Такой вариант функции `add` называется **сильно-чистой функцией**,
поскольку возвращает результат, зависящий только от параметров,
и не изменяет сами параметры. D так же позволяет определять
**слабо-чистые функции**, которые могут иметь изменяемые
параметры:

    void add(ref int result, int lhs, int rhs)
    pure {
        result = lhs + rhs;
    }

Такие функции всё ещё считаются чистыми, и не могут
обращаться к или изменять глобальное состояние, а только
лишь переданные изменяемые параметры.

Благодаря ограничениям, накладываемым `pure`, чистые функции
идеально подходят для многопоточных сред, поскольку
предотвращают состояние гонки *по дизайну*.
В дополнение к этому, результаты чистых функций
легко поддаются кэшированию, что открывает ряд
возможностей для оптимизации во время компиляции.

Атрибут `pure` автоматически вычисляется компилятором
для шаблонных и `auto`-функций, если это возможно
(это так же справедливо для `@safe`, `nothrow`, и `@nogc`).

### Подробнее

- [Functional DLang Garden](https://garden.dlang.io/)

## {SourceCode}

```d
import std.bigint : BigInt;

/**
 * Возводит число в степень.
 *
 * Returns:
 *     Степеь числа в виде целого числа
 *     произвольного размера.
 */
BigInt bigPow(uint base, uint power) pure
{
    BigInt result = 1;

    foreach (_; 0 .. power)
        result *= base;

    return result;
}

void main()
{
    import std.datetime : benchmark, to;
    import std.functional : memoize;
    import std.stdio : writefln, writeln;

    // memoize кэширует результат функции,
    // в зависимости от переданных параметров.
    // чистые функции идеально
    // для этого подходят!
    alias fastBigPow = memoize!(bigPow);

    void test()
    {
        writefln(".uintLength() = %s ",
        	  fastBigPow(5, 10000).uintLength);
    }

    foreach (i; 0 .. 10)
        benchmark!test(1)[0]
        	.to!("msecs", double)
        	.writeln("заняло: миллисекунд");
}
```
